# This file is dual licensed under the terms of the Apache License, Version
# 2.0, and the BSD License. See the LICENSE file in the root of this repository
# for complete details.
INCLUDES = "\n\n#include <openssl/dh.h>\n\n"
TYPES = "\n\ntypedef ... DH;\n\n\n\nconst long DH_NOT_SUITABLE_GENERATOR;\n\n"
FUNCTIONS = "\n\nDH *DH_new(void);\n\nvoid DH_free(DH *);\n\nint DH_size(const DH *);\n\nint DH_generate_key(DH *);\n\nDH *DHparams_dup(DH *);\n\n\n\n/* added in 1.1.0 when the DH struct was opaqued */\n\nvoid DH_get0_pqg(const DH *, const BIGNUM **, const BIGNUM **,\n\n                 const BIGNUM **);\n\nint DH_set0_pqg(DH *, BIGNUM *, BIGNUM *, BIGNUM *);\n\nvoid DH_get0_key(const DH *, const BIGNUM **, const BIGNUM **);\n\nint DH_set0_key(DH *, BIGNUM *, BIGNUM *);\n\n\n\nint Cryptography_DH_check(const DH *, int *);\n\nint DH_generate_parameters_ex(DH *, int, int, BN_GENCB *);\n\nDH *d2i_DHparams_bio(BIO *, DH **);\n\nint i2d_DHparams_bio(BIO *, DH *);\n\nDH *Cryptography_d2i_DHxparams_bio(BIO *bp, DH **x);\n\nint Cryptography_i2d_DHxparams_bio(BIO *bp, DH *x);\n\n"
CUSTOMIZATIONS = "\n\n#if CRYPTOGRAPHY_IS_LIBRESSL\n\n#ifndef DH_CHECK_Q_NOT_PRIME\n\n#define DH_CHECK_Q_NOT_PRIME            0x10\n\n#endif\n\n\n\n#ifndef DH_CHECK_INVALID_Q_VALUE\n\n#define DH_CHECK_INVALID_Q_VALUE        0x20\n\n#endif\n\n\n\n#ifndef DH_CHECK_INVALID_J_VALUE\n\n#define DH_CHECK_INVALID_J_VALUE        0x40\n\n#endif\n\n\n\n/* DH_check implementation taken from OpenSSL 1.1.0pre6 */\n\n\n\n/*-\n\n * Check that p is a safe prime and\n\n * if g is 2, 3 or 5, check that it is a suitable generator\n\n * where\n\n * for 2, p mod 24 == 11\n\n * for 3, p mod 12 == 5\n\n * for 5, p mod 10 == 3 or 7\n\n * should hold.\n\n */\n\n\n\nint Cryptography_DH_check(const DH *dh, int *ret)\n\n{\n\n    int ok = 0, r;\n\n    BN_CTX *ctx = NULL;\n\n    BN_ULONG l;\n\n    BIGNUM *t1 = NULL, *t2 = NULL;\n\n\n\n    *ret = 0;\n\n    ctx = BN_CTX_new();\n\n    if (ctx == NULL)\n\n        goto err;\n\n    BN_CTX_start(ctx);\n\n    t1 = BN_CTX_get(ctx);\n\n    if (t1 == NULL)\n\n        goto err;\n\n    t2 = BN_CTX_get(ctx);\n\n    if (t2 == NULL)\n\n        goto err;\n\n\n\n    if (dh->q) {\n\n        if (BN_cmp(dh->g, BN_value_one()) <= 0)\n\n            *ret |= DH_NOT_SUITABLE_GENERATOR;\n\n        else if (BN_cmp(dh->g, dh->p) >= 0)\n\n            *ret |= DH_NOT_SUITABLE_GENERATOR;\n\n        else {\n\n            /* Check g^q == 1 mod p */\n\n            if (!BN_mod_exp(t1, dh->g, dh->q, dh->p, ctx))\n\n                goto err;\n\n            if (!BN_is_one(t1))\n\n                *ret |= DH_NOT_SUITABLE_GENERATOR;\n\n        }\n\n        r = BN_is_prime_ex(dh->q, BN_prime_checks, ctx, NULL);\n\n        if (r < 0)\n\n            goto err;\n\n        if (!r)\n\n            *ret |= DH_CHECK_Q_NOT_PRIME;\n\n        /* Check p == 1 mod q  i.e. q divides p - 1 */\n\n        if (!BN_div(t1, t2, dh->p, dh->q, ctx))\n\n            goto err;\n\n        if (!BN_is_one(t2))\n\n            *ret |= DH_CHECK_INVALID_Q_VALUE;\n\n        if (dh->j && BN_cmp(dh->j, t1))\n\n            *ret |= DH_CHECK_INVALID_J_VALUE;\n\n\n\n    } else if (BN_is_word(dh->g, DH_GENERATOR_2)) {\n\n        l = BN_mod_word(dh->p, 24);\n\n        if (l == (BN_ULONG)-1)\n\n            goto err;\n\n        if (l != 11)\n\n            *ret |= DH_NOT_SUITABLE_GENERATOR;\n\n    } else if (BN_is_word(dh->g, DH_GENERATOR_5)) {\n\n        l = BN_mod_word(dh->p, 10);\n\n        if (l == (BN_ULONG)-1)\n\n            goto err;\n\n        if ((l != 3) && (l != 7))\n\n            *ret |= DH_NOT_SUITABLE_GENERATOR;\n\n    } else\n\n        *ret |= DH_UNABLE_TO_CHECK_GENERATOR;\n\n\n\n    r = BN_is_prime_ex(dh->p, BN_prime_checks, ctx, NULL);\n\n    if (r < 0)\n\n        goto err;\n\n    if (!r)\n\n        *ret |= DH_CHECK_P_NOT_PRIME;\n\n    else if (!dh->q) {\n\n        if (!BN_rshift1(t1, dh->p))\n\n            goto err;\n\n        r = BN_is_prime_ex(t1, BN_prime_checks, ctx, NULL);\n\n        if (r < 0)\n\n            goto err;\n\n        if (!r)\n\n            *ret |= DH_CHECK_P_NOT_SAFE_PRIME;\n\n    }\n\n    ok = 1;\n\n err:\n\n    if (ctx != NULL) {\n\n        BN_CTX_end(ctx);\n\n        BN_CTX_free(ctx);\n\n    }\n\n    return (ok);\n\n}\n\n#else\n\nint Cryptography_DH_check(const DH *dh, int *ret) {\n\n    return DH_check(dh, ret);\n\n}\n\n#endif\n\n\n\n/* These functions were added in OpenSSL 1.1.0f commit d0c50e80a8 */\n\n/* Define our own to simplify support across all versions. */\n\n#if defined(EVP_PKEY_DHX) && EVP_PKEY_DHX != -1\n\nDH *Cryptography_d2i_DHxparams_bio(BIO *bp, DH **x) {\n\n    return ASN1_d2i_bio_of(DH, DH_new, d2i_DHxparams, bp, x);\n\n}\n\nint Cryptography_i2d_DHxparams_bio(BIO *bp, DH *x) {\n\n    return ASN1_i2d_bio_of_const(DH, i2d_DHxparams, bp, x);\n\n}\n\n#else\n\nDH *(*Cryptography_d2i_DHxparams_bio)(BIO *bp, DH **x) = NULL;\n\nint (*Cryptography_i2d_DHxparams_bio)(BIO *bp, DH *x) = NULL;\n\n#endif\n\n"
